import java.util.ArrayList;
import java.util.Collection;
import java.util.Comparator;
import java.util.HashMap;
import java.util.Iterator;
import java.util.Set;
import java.util.Vector;

import AugmentedTree.IntervalTree;

public class Gene extends Region{

	
	public static void main(String[] args){
		Annotation a = new Annotation("id", "name", "str", '-', "test");
		IntervalTree<Region> test = new IntervalTree<Region>();
		Region r1 = new Region(1,2,a);
		
		
		ArrayList<Region> posCheck = new ArrayList<Region>();
		posCheck = test.getIntervalsBeginAt(1, posCheck);
		System.out.println(posCheck.toString());
	}
	
	private HashMap<String,Transcript> transcripts;
	
	public Gene(int x1, int x2, Annotation annotation){
		super(x1,x2,annotation);
		transcripts = new HashMap <String,Transcript>();
	}

	public Gene(int x1, int x2, Annotation annotation, Annotation subannotation){
		super(x1,x2,annotation);
		transcripts = new HashMap <String,Transcript>();
		transcripts.put(subannotation.getId(),new Transcript(x1,x2,subannotation));
	}

	public int getTranscriptNumber(){
		int n = 0;
		for( String k : transcripts.keySet() ){
			if(transcripts.get(k).getRegionsTree().size() > 0){
				n ++;
			}
		}
		return n;
	}
	
	public int getProteinNumber(){
		int n = 0;
		for( String k : transcripts.keySet() ){
			n += transcripts.get(k).getProtNum();
		}
		return n;
	}
	
	public ArrayList<ExonSkip> getExonSkips() {
		IntervalTree<Region> introns = new IntervalTree<Region>();
		for( String k : transcripts.keySet() ){
			Transcript curTran = transcripts.get(k);
			if(curTran.setIntrons()){
				introns.addAll(curTran.getIntrons());
			}
		}
		//introns holds all introns
		
		IntervalTree<Region> mergeIntrons = new IntervalTree<Region>();
		Iterator<Region> iterator = introns.iterator();
		int lastStart = -1;
		int lastStop = -1;
		int curStart = -2;
		int curStop = -2;
		while(iterator.hasNext()){
			Region curIntron = iterator.next();
			curStart = curIntron.getStart();
			curStop = curIntron.getStop();
			if(lastStart == curStart && lastStop == curStop){
				
			}
			else{
				ArrayList<Region> sameIntron = new ArrayList<Region>();
				sameIntron = introns.getIntervalsEqual(curStart, curStop, sameIntron);
				Region mergeIntron = curIntron;
				for( Region r : sameIntron){
					mergeIntron = mergeIntron.merge(r);
				}
				mergeIntrons.add(mergeIntron);
			}
		}
		//mergeIntrons holds all distinct introns
		
		Iterator<Region> mergeIterator = mergeIntrons.iterator();
		while(mergeIterator.hasNext()){
			Region sv = mergeIterator.next();
			int svstart = sv.getStart();
			int svstop = sv.getStop();
			
			ArrayList<Region> wt_candidates = new ArrayList<Region>();
			mergeIntrons.getIntervalsSpanning(svstart, wt_candidates);
			
			ArrayList<String> wt_transcript_ids = new ArrayList<String>();
			
			for(Region wt_candidate: wt_candidates){
				if(wt_candidate.getStart() == svstart){
					wt_transcript_ids.addAll(wt_candidate.getAnnotation().getSuperIds());
				}
			}
			
			
			
			for(String id : wt_transcript_ids){
				Transcript wtt = transcripts.get(id);
				IntervalTree<Region> wtt_introns = wtt.getIntrons();
				
				ArrayList<Region> wtt_wt = new ArrayList<Region>();
				wtt_wt = wtt_introns.getIntervalsSpannedBy(svstart, svstop, wtt_wt);
				wtt_wt.sort(new StartRegionComparator());
				if(wtt_wt.get(0).getStart() == svstart && wtt_wt.get(wtt_wt.size()).getStop() == svstop){
					
				}
			}
			
		}
		
		
		return null;
	}
	
	public void removeEmpty(){
		for( String k : transcripts.keySet() ){
			if(transcripts.get(k).getRegionsTree().size() == 0){
				transcripts.remove(k);
			}
		}
	}
	
	public int hashCode(){
		return this.getAnnotation().hashCode();
	}
	
	public String toString(){
		String output = "Gene: "+ super.toString() + "\n";
		for( String k : transcripts.keySet() ){
			output += transcripts.get(k).toString();
		}
		return output;
	}

	public void add(Transcript trans) {
		this.transcripts.put(trans.getAnnotation().getId(), trans);
	}
	
	class StartRegionComparator implements Comparator<Region>
	{
	    public int compare(Region x1, Region x2)
	    {
	        return x1.getStart() - x2.getStart();
	    }
	}
}

