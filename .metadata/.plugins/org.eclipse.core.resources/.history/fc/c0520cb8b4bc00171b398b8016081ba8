import java.util.Collection;
import java.util.Collections;
import java.util.Comparator;
import java.util.Iterator;
import java.util.Set;
import java.util.Vector;

import AugmentedTree.IntervalTree;

public class RegionVector {
	
	public static void main(String[] args) {
		RegionVector rv1 = new RegionVector(1,50);
		RegionVector rv2 = new RegionVector(2,12);
		RegionVector rv3 = new RegionVector(3,12);
		RegionVector r1 = rv1.merge(rv2).merge(rv3);
		
		System.out.println(r1.merge().getRegionsTree().toTreeString());
		
		RegionVector rv4 = new RegionVector(4,9);
		RegionVector rv5 = new RegionVector(60,80);
		
		RegionVector r2 = r1.merge(rv4).merge(rv5);
		
		System.out.println(r2.merge().getRegionsTree().toTreeString());
	}

	private IntervalTree<Region> regions;

	public RegionVector(int x1, int x2){
		regions = new IntervalTree<Region>();
		regions.add(new Region(x1,x2));
	}
	
	public RegionVector(IntervalTree<Region> region){	
		this.regions = region;
	}
	
	public RegionVector(Vector<Region> region){
		
		regions = new IntervalTree<Region>();
		regions.addAll(region);
	}
	
	public RegionVector(Region[] region){
		
		regions = new IntervalTree<Region>();
		for(int i = 0; i < region.length; i++){
			regions.add(region[i]);
		}
	}
	
	public Region[] getRegionsArray(){
		return (Region[]) regions.toArray();
	}
	
	public IntervalTree<Region> getRegionsTree(){
		return regions;
	}
	
	public Vector<Region> getRegions(){
		Vector <Region> r = new Vector<Region>();
		Region[] regionArray = (Region[]) regions.toArray();
		for(int i = 0; i < regionArray.length; i++){
			r.add(regionArray[i]);
		}
		return r;
	}
	
	public RegionVector merge(){
		
		Vector<Region> resultV = new Vector<Region>();

		Iterator<Set<Region>> iterator = regions.groupIterator();
		while(iterator.hasNext()){
			Collection<Region> overlap = (Collection<Region>) iterator.next();
			Vector<Region> overlapVector = new Vector<Region>(overlap);
			int start = overlapVector.get(0).getStart();
			overlapVector.sort(new StopRegionComparator());
			int stop = overlapVector.lastElement().getStop();
			resultV.add(new Region(start,stop));
		}
		
		return new RegionVector(resultV);
   
	}
	
	public RegionVector merge(RegionVector rv){

		regions.addAll(rv.getRegionsTree());
		RegionVector results = new RegionVector(regions); 
		
        return results;
	}
	
	public RegionVector subtract(RegionVector rv){
		
		regions.sort(new StartRegionComparator());
		
		Vector<Region> sub = rv.getRegions();
		sub.sort(new StartRegionComparator());

        Vector<Region> resultV = new Vector<Region>();
        
        int j = 0;
        int i = 0;
        while (i < regions.size()) {
            Region current = regions.get(i);
            int start = current.getStart();
            int stop = current.getStop();
            Region cursub = sub.get(j);
            int substart = cursub.getStart();
            int substop = cursub.getStop();
            while(substop-1 < start && j < sub.size()){
            	j++;
            	if(j < sub.size()){
            		cursub = sub.get(j);
            		substart = cursub.getStart();
            		substop = cursub.getStop();
            	}
            }
            while(substop < stop && substop-1 >= start && j < sub.size()){
            	substart = cursub.getStart();
            	substop = cursub.getStop();
            	if (start < substart) {
            		resultV.add(new Region(start, substart));
            		start = substop;
            		j++;
            		
            	}
            	else{
            		start = substop;
            		j++;
            	}
            	if(j < sub.size()){
            		cursub = sub.get(j);
            		substart = cursub.getStart();
                	substop = cursub.getStop();
            	}
            }
            if(substop >= stop && substart < stop && substart > start){
            	resultV.add(new Region(start, substart));
            }
            else if(substop >= stop && substart <= start){
            	
            }
            else{
            	resultV.add(new Region(start,stop));
            }
            i++;
        }
        return new RegionVector(resultV);
		
	}
	
	public int length(){
		if(regions.size() > 0){
			return (regions.get(regions.size()-1).getStop() - regions.get(0).getStart());
		}
		else{
			return 0;
		}
	}
	
	public RegionVector invert(){
		Vector<Region> resultV = new Vector<Region>();
		for(int i = 0; i < regions.size()-1; i++){
			resultV.add(new Region(regions.get(i).getStop(), regions.get(i+1).getStart()));
		}
		return new RegionVector(resultV);
	}
	
	public int coveredLength(){
		int l = 0;
		for(int i = 0; i < regions.size(); i++ ){
			l += regions.get(i).length();
		}
		return l;
	}
	
	public RegionVector getCoveredRegion(RegionVector rv){
		Vector<Region> rvregions = rv.getRegions();
		Vector<Region> resultV = new Vector<Region>();
		for(int i = 0; i < rvregions.size(); i++){
			int start;
			int stop;
			int startloc = Collections.binarySearch(regions, rvregions.get(i), new StartRegionComparator());
			int stoploc = Collections.binarySearch(regions, rvregions.get(i), new StopRegionComparator());
			System.out.println(startloc);
			System.out.println(stoploc);
			
			if(startloc > 0){
				start = startloc;
			}
			else{
				start = (-1*startloc)-2;
			}
			if(stoploc > 0){
				stop = stoploc;
			}
			else{
				stop = (-1*stoploc)-1;
			}
			for(int j = start; j <= stop; j++){
				resultV.add(regions.get(j));
			}
		}
		return new RegionVector(resultV);
	}
	
	class StartRegionComparator implements Comparator<Region>
	{
	    public int compare(Region x1, Region x2)
	    {
	        return x1.getStart() - x2.getStart();
	    }
	}
	
	class StopRegionComparator implements Comparator<Region>
	{
	    public int compare(Region x1, Region x2)
	    {
	        return x1.getStop() - x2.getStop();
	    }
	}
}
